<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhancement Two — Omer Cengiz ePortfolio</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="ambient"><div class="ambient-orb"></div><div class="ambient-orb"></div><div class="ambient-orb"></div></div>

  <nav class="nav">
    <div class="nav-inner">
      <a href="index.html" class="nav-logo">Omer Cengiz</a>
      <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')">&#9776;</button>
      <ul class="nav-links">
        <li><a href="index.html">Home</a></li>
        <li><a href="code-review.html">Code Review</a></li>
        <li><a href="enhancement-one.html">Enhancement 1</a></li>
        <li><a href="enhancement-two.html" class="active">Enhancement 2</a></li>
        <li><a href="enhancement-three.html">Enhancement 3</a></li>
        
      </ul>
    </div>
  </nav>

  <main class="main">
    <header class="page-header">
      <span class="label">02 — Algorithms &amp; Data Structures</span>
      <h1>MongoDB Text Indexes &amp; Optimized Search</h1>
      <p>Replacing O(n) client-side filtering with O(log n) database-level search using inverted indexes and B-tree structures.</p>
    </header>

    <section class="section">
      <h2>The Problem</h2>
      <p>The original search implementation fetched every trip from the database using an empty query (<code>Trip.find({})</code>), then looped through all results in JavaScript using the <code>includes()</code> method to find matches across name, resort, description, and code fields. This is O(n) complexity — every trip is checked for every search.</p>
      <div class="info-box">
        <p>This search approach was not only slow, it was also broken. The Playwright tests from Enhancement One discovered that the search could not find trips even when they should have matched. Instead of patching the broken logic, this enhancement replaced the entire approach.</p>
      </div>
    </section>

    <section class="section">
      <h2>The Solution</h2>
      <p>The search was moved to MongoDB using text indexes, which use an inverted index structure backed by B-trees. Instead of scanning every document, MongoDB maintains a prebuilt index of searchable terms. When a user searches, MongoDB looks up the term in the index and returns only matching documents — O(log n) complexity.</p>
      <h3>Weighted Text Index</h3>
      <p>A compound text index was added to the Trip schema with weighted fields that determine relevance ranking:</p>
      <table class="comparison-table">
        <thead><tr><th>Field</th><th>Weight</th><th>Rationale</th></tr></thead>
        <tbody>
          <tr><td>name</td><td class="highlight">10</td><td>Most relevant — users typically search by trip name</td></tr>
          <tr><td>resort</td><td class="highlight">5</td><td>High relevance — resort name is a common search target</td></tr>
          <tr><td>category</td><td class="highlight">3</td><td>Moderate — surfaces trips in matching categories</td></tr>
          <tr><td>description</td><td class="highlight">1</td><td>Lowest — provides broad matching without dominating results</td></tr>
        </tbody>
      </table>
      <p>MongoDB calculates relevance scores automatically using the <code>$meta: 'textScore'</code> operator. A trip with "beach" in the name scores higher than one that only mentions "beach" in the description.</p>
      <h3>Combined Filtering</h3>
      <p>The API controller now accepts <code>search</code> and <code>category</code> as query parameters, building MongoDB queries with the <code>$text</code> operator. Both filters work together — users can search "luxury" within just the cruise category. Category tab badges display accurate counts through a separate aggregation call.</p>
    </section>

    <section class="section">
      <h2>Scalability Comparison</h2>
      <table class="comparison-table">
        <thead><tr><th>Dataset Size</th><th>Client-Side Filtering (O(n))</th><th>Text Index Search (O(log n))</th></tr></thead>
        <tbody>
          <tr><td>100 trips</td><td>~400 comparisons</td><td class="highlight">~7 lookups</td></tr>
          <tr><td>1,000 trips</td><td>~4,000 comparisons</td><td class="highlight">~10 lookups</td></tr>
          <tr><td>10,000 trips</td><td>~40,000 comparisons</td><td class="highlight">~13 lookups</td></tr>
          <tr><td>100,000 trips</td><td>~400,000 comparisons</td><td class="highlight">~17 lookups</td></tr>
        </tbody>
      </table>
    </section>

    <section class="section">
      <h2>Technical Details</h2>
      <ul>
        <li><strong>Inverted index structure</strong> — MongoDB builds a mapping from terms to documents, backed by B-trees for fast lookups</li>
        <li><strong>Word-based matching with stemming</strong> — "beach" matches "beach" and "beaches" but not "beachfront," which is more precise than substring matching</li>
        <li><strong>URLSearchParams</strong> for clean parameter handling between the customer controller and API</li>
        <li><strong>Custom Handlebars helper (eq)</strong> for active state management on category filter tabs</li>
        <li><strong>Separate category count API call</strong> to maintain accurate tab badge numbers even when filtering</li>
      </ul>
    </section>

    <section class="section">
      <h2>Skills &amp; Outcomes</h2>
      <div class="tags">
        <span class="tag">Algorithm Analysis</span><span class="tag">Database Indexing</span><span class="tag">MongoDB Aggregation</span><span class="tag">B-Tree Structures</span><span class="tag">Performance Optimization</span>
      </div>
      <div class="tags" style="margin-top: 0.5rem;">
        <span class="tag tag--outcome">Outcome 3 — Design &amp; Evaluate Solutions</span>
        <span class="tag tag--outcome">Outcome 4 — Tools &amp; Techniques</span>
      </div>
      <p style="margin-top: 1rem;"><strong>Outcome 3:</strong> This enhancement is fundamentally about algorithm selection — evaluating O(n) client-side filtering against O(log n) indexed search and analyzing trade-offs around development complexity, query flexibility, and scalability.</p>
      <p><strong>Outcome 4:</strong> MongoDB text indexes, the <code>$text</code> query operator, relevance scoring with <code>$meta</code>, and aggregation pipelines are industry-standard tools for implementing search functionality.</p>
    </section>

    <div style="margin-top: 2rem;">
      <a href="https://github.com/omerfarukcengizzzz/CS-499" target="_blank" class="btn btn-primary">View Code on GitHub</a>
      <a href="enhancement-three.html" class="btn btn-outline" style="margin-left: 0.75rem;">Next: Enhancement Three &rarr;</a>
    </div>

    <footer class="footer">
      <p>Omer Cengiz &mdash; CS 499 Computer Science Capstone &mdash; Southern New Hampshire University</p>
      <p style="margin-top: 0.5rem;"><a href="https://github.com/omerfarukcengizzzz" target="_blank">GitHub</a></p>
    </footer>
  </main>
</body>
</html>
